
## 单调栈
保持栈内元素大小是单调递增/递减的
每要添加一个元素，判断元素加到栈顶是否满足单调性，不满足则弹出栈顶元素，直到满足，再将新元素加到栈顶
### 例题
输入N，然后输入N个数，按顺序输出每个数左边第一个比他小的数，不存在则输出-1
```cpp
const int N=1e5+10;
int stk[N],tt;
int main(){
    int n,x;
    cin >> n;
    for(int i=0;i<n;i++){
        cin >> x;
        while(tt&&stk[tt]>=x) tt--;
        if(tt==0) cout << -1 << ' ';
        else cout << stk[tt] << ' ';
        stk[++tt]=x;
    }
    return 0;
}
```
## 单调队列(左头右尾)(o(n))
从队尾入队/出队，队头出队，保持队列内元素大小是单调递增/递减的。队列存的是指针(下标)
添加元素时，判断新元素是否满足单调性，不满足则队尾不断弹出元素（--tt），直到满足，新元素队尾入队。滑动窗口移动时，判断队头是否出队`if(qe[hh]<i-k+1) ++hh; //(k为窗口长度)`。
*模板*
```
//求min(a(i-k+1)~a(i)),即维护窗口最小值
int hh=1,tt=0;
int qe[MN];
for(int i=1;i<=n;i++){
	while(hh<=tt && a[qe[tt]]>=a[i]) --tt;//队尾出队(队列不空且新元素更优)
	qe[++tt]=i;  //队尾入队
	if(qe[hh]<i-k+1) ++hh;  //判断队头是否滑出窗口
}
```
### 例题
有一个大小为 k 的滑动窗口，它从数组的最左边移动到最右边。
你只能在窗口中看到 k 个数字。
每次滑动窗口向右移动一个位置。
以下是一个例子：
该数组为 `[1 3 -1 -3 5 3 6 7]`，k 为 3。

|窗口位置|最小值|最大值|
|:-:|:-:|:-:|
|[1 3 -1] -3 5 3 6 7|-1|3|
|1 [3 -1 -3] 5 3 6 7|-3|3|
|1 3 [-1 -3 5] 3 6 7|-3|5|
|1 3 -1 [-3 5 3] 6 7|-3|5|
|1 3 -1 -3 [5 3 6] 7|3|6|
|1 3 -1 -3 5 [3 6 7]|3|7|
你的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。
#### 输入样例：

```
8 3
1 3 -1 -3 5 3 6 7
```

#### 输出样例：

```
-1 -3 -3 -3 3 3
3 3 5 5 6 7
```
#### 题解
```
const int N=1e6+10;
int que[N],a[N];
int hh=1,tt=0;
int main(){
    ios::sync_with_stdio; cin.tie(nullptr);
    int n,k;
    cin >> n >> k;
    for(int i=0;i<n;i++) cin >> a[i];
    for(int i=0;i<n;i++){
        if(hh<=tt&&i-k+1>que[hh]) hh++;  //窗口每次滑动1，用if，hh++一次就行
        while(hh<=tt&&a[que[tt]]>a[i]) tt--;
        que[++tt]=i;
        if(i>=k-1) cout << a[que[hh]] << ' ';  //求窗口最小值，构造递增队列
    }
    cout << '\n';
    hh=1,tt=0;
    for(int i=0;i<n;i++){
        if(hh<=tt&&i-k+1>que[hh]) hh++;
        while(hh<=tt&&a[que[tt]]<a[i]) tt--;
        que[++tt]=i;
        if(i>=k-1) cout << a[que[hh]] << ' ';   ////求窗口最大值，构造递减队列
    }
    
    return 0;    
}
```