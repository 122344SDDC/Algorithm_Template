*思路*（原理基于DP,o(n^3)）
求最短路三重循环`k,i,j`,`g[i][j]=min(g[i][j],g[i][k]+g[k][j]);`则得出所有`i`到`j`的最短距离为`g[i][j]`.若要保留路径,则开一个`p[][]`，`if(g[i][j]>g[i][k]+g[k][j])  p[i][j]=k`，`p[i][j]`表示`i`到`j`最短路径上`i`的下一个点。求最短路径时以此点迭代，不断往后推直到推到`j` 的上一个点即可得最短路径，即`p[i][j]->k1; p[k1][j]->k2 p[k2][j]->k3·····`
###### 注意
- 初始化所有`g[i][j]`为无穷，然后再将所有`g[i][i]=0`
- 输入边权时保留最小`g[a][b]=min(g[a][b],w);`
```cpp
for(int k=1;k<=n;k++){
  for(int i=1;i<=n;i++){
    for(int j=1;j<=n;j++)g[i][j]=min(g[i][j],g[i][k]+g[k][j]);	
	  }
}
```